# Linear Memory & GC Runtime
## Regions
Note that for some of this we might be able to define [custom sections](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Module/customSections).

### Roots/Reference Stack
- Pointers cannot be on WASM stack because we need to be able to mark and update them
- Will need associated mutable global `$ref_sp`
- Size: Probably fixed 1-3 mb, modifyable via compiler flag

### Nursery
- This is where the shortest lived objects are stored. Doing a generational Garbage collector
- Associated mutable globals for optimizations
- Size: Probably fixed 512 kb

### User Static Data
- Used for storing things like string literals and `static_region` + `static_init_byte`
- Size: known at compile time but determined by what the program does

### Heap
- Longer term objects stored as described below
- Size: variable at runtime

## Heap Object Headers
Stores metadata for the relevant object pointer. Below examples are in C/C++ only for readability, planning on writing it directly in WASM.
```cpp
struct gc_heap_object_t {
    // This tells us where within the object there are references
    // - Each bit represents a 32 bit block
    // - pointer to bitfield stored in static memory, generated by compiler
    // - if nullptr then it contains no references
    // - length = this->size / 8
    void* refs_bitfield_addr;  // uint32_ptr_t

    // Referenced by other nodes?
    // Used during mark phase
    bool mark : 2;

    // How much storage do we have allocated (multiples of 32 bits)
    unsigned size : 30

    // Next pointer so that we can iterate over and free pointers
    struct gc_heap_object_t* next; // uint32_ptr_t
};
```

## Free space LL
Nodes in the linked list are stored at the start of free space regions, so the address of the node is the start
```cpp
struct gc_heap_empty_t {
    // Note that this is a header for unused regions
    // thus implied: void* start_addr = this;

    // How much free space do we have here
    // - multiples of 32 bits
    // - could be smaller
    uint32_t size;

    // Next available free space
    struct gc_heap_empty_t* next; // uint32_ptr_t
};

// Root element of LL
struct gc_heap_empty_t* gc_free_start;
```

Notice that due to implementation, the order of the free spaces will match their order of creation and thus their order in LM. With this in mind we can define our coalesce functions as such

```C++
void coalesce_heap() {
    for (auto* p = start; p->next; p = p->next)
        if (p + p->size === p->next) {
            p->size += p->next->size;
            p->next = p->next->next;
        }
}
```

## GC behavior
### Use
- On the value stack, reference/root stack indicies are passed around
- To get an address the index is dereferenced
- To get values, an address is dereferenced

### Minor - Mark
- Go through the values in the root/ref stack
- if the item is in the nursery, recursively mark it's references (which are also in the nursery)

### Minor - Sweep
After sweep, go through nursery, any values marked get copied into the main heap (TODO elaborate on this lol)

#### Major - Mark
- Values in the root/ref stack get marked
- Recursively follow pointers from the references bitmask and mark the

#### Major Sweep
- Starting at the first gc heap object
- Iterate through the LL, deleting unmarked objects

## Room for Improvement
- Segregation based on the size of the values being stored
- Probably a lot of room for optimization and reduce number of linked lists

## ABI
Rough ideas for the implmentation
### User-facing
- `fun $__gc_alloc (param i32 $size, i32 $bitmask_adddr) (result i32 $address)`:
    - allocates an object on the heap, returns pointer to the object
    - afterwards need to initialize the memory in this location
    - if nursery is too full to allocate, do a minor gc
    - if this is our 10th (arbirtrary) minor GC, do a major gc

### Internal Internal use only
- `$do_minor_gc`, `$do_major_gc`, `mark_minor`, `sweep_minor`, `mark_major`, `sweep_major`, ...
- `$coalesce`: goes through the free-space linked list and connects adjacent free spaces

### Mutable Globals
- `$ref_sp`: head of the reference stack
- `$gc_object_ll_head`: first gc'd object